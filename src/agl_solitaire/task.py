"""Class responsible for driving most of the actual experimental procedure."""

import dataclasses
import datetime
import os
import random
import re

try:
    random.seeded
except AttributeError:
    import time
    random.seed(time.time())


from src.agl_solitaire.grammar import Grammar
from src.agl_solitaire.settings import Settings


# FIXME: copypasta from Application :S
_LEFT_MARGIN_WIDTH = 2

_builtin_print = print

def print(string='', end='\n'):
    """Smarter print function, adds left margin and wraps long lines automatically."""
    max_width = os.get_terminal_size().columns
    wrapped_string = ''
    for line in string.split('\n'):
        carriage_return = re.match(r'\r', line)
        if carriage_return:
            line = line[1:]
        line = ' ' * _LEFT_MARGIN_WIDTH + line
        if carriage_return:
            line = '\r' + line
        while max_width < len(line):
            stop_at = max_width - 1
            # back up to the nearest word boundary
            while 0 <= stop_at and not line[stop_at].isspace():
                stop_at -= 1
            if -1 == stop_at:
                # one giant word, we give up and leave it unwrapped
                stop_at = len(line)
            wrapped_string += line[:stop_at] + '\n'
            line = line[stop_at+1:]
            line = ' ' * _LEFT_MARGIN_WIDTH + line
        wrapped_string += line + '\n'
    # leave off the last newline
    _builtin_print(wrapped_string[:-1], end=end)

_builtin_input = input

def input(prompt='> '):
    """input function with constant left margin for improved readability."""
    return _builtin_input(' ' * _LEFT_MARGIN_WIDTH + prompt)

_which_clear = None

def clear():
    """Find the right clear screen command by trial-and-error and remember it."""
    global which_clear
    try:
        which_clear
    except NameError:
        which_clear = 'cls'
    if os.system(which_clear):
        # non-zero exit code, try the other command
        (which_clear,) = set(['cls', 'clear']) - set([which_clear])
        os.system(which_clear)


# TODO: see if we can merge this with ExperimentState?
@dataclasses.dataclass
class Task:
    """Represents one AGL test to be done by the user, possibly in a series of several."""

    grammar: Grammar
    settings: Settings

    # FIXME: copypasta from Application :S
    def duplicate_print(self, string, log_only=False):
        """Output the string on the screen and log it in a text file at the same time."""
        if not log_only:
            print(string)
        with open(self.settings.logfile_filename, 'a', encoding='UTF-8') as logfile:
            # prepend timestamp
            stamped_list = ['[' + str(datetime.datetime.now().replace(microsecond=0)) + '] ' + line.strip() for line in string.split('\n')]
            stamped_string = '\n'.join(stamped_list)
            logfile.write(stamped_string + '\n')

    def prepare(self):
        """Populate training and test sets with output generated by our grammar."""
        if ( self.settings.experiment_state.training_set and
             self.settings.experiment_state.test_set ):
            return
        assert 0 < self.settings.training_strings
        assert 0 < self.settings.test_strings_grammatical
        assert 0 < self.settings.test_strings_ungrammatical
        num_required_grammatical = self.settings.training_strings + self.settings.test_strings_grammatical
        if not self.settings.grammar_class.custom():
            grammatical_strings = self.grammar.produce_grammatical(num_strings=num_required_grammatical,
                                                                   min_length=self.settings.minimum_string_length,
                                                                   max_length=self.settings.maximum_string_length)
        else:
            grammatical_strings = self.grammar.produce_grammatical(num_required_grammatical)
        if grammatical_strings is None:
            return False
        grammatical_strings = list(grammatical_strings)
        if not self.settings.grammar_class.custom():
            ungrammatical_strings = self.grammar.produce_ungrammatical(num_strings=self.settings.test_strings_ungrammatical,
                                                                       min_length=self.settings.minimum_string_length,
                                                                       max_length=self.settings.maximum_string_length)
        else:
            ungrammatical_strings = self.grammar.produce_ungrammatical(num_strings=self.settings.test_strings_ungrammatical)
        # partition grammatical_strings into two subsets
        picked_for_training = random.sample(range(0,num_required_grammatical), k=self.settings.training_strings)
        self.settings.experiment_state.training_set = [grammatical_strings[i] for i in picked_for_training]
        self.settings.experiment_state.test_set = [(grammatical_strings[i], 'y', None) for i in set(range(0,num_required_grammatical)) - set(picked_for_training)]
        self.settings.experiment_state.test_set += [(string, 'n', None) for string in ungrammatical_strings]
        assert len(self.settings.experiment_state.test_set) == self.settings.test_strings_grammatical + self.settings.test_strings_ungrammatical
        # permute test set
        random.shuffle(self.settings.experiment_state.test_set)
        return True

    def run(self):
        """Let the user perform this generated task."""
        assert self.settings.experiment_state
        assert self.settings.experiment_state.training_set
        assert self.settings.experiment_state.test_set
        # used for sleeping but keeping the keyboard awake
        input_thread = None
        if not self.settings.experiment_state.training_finished:
            if self.settings.training_one_at_a_time:
                the_same = 'the same ' if 1 < self.settings.training_reps else ''
                in_rounds = f"in {self.settings.training_reps} rounds " if 1 < self.settings.training_reps else ''
                time_per_item = round(float(self.settings.training_time) / self.settings.training_strings, 2)
                self.duplicate_print(f"The training phase will now begin. You will be presented with {the_same}{self.settings.training_strings} exemplars of the hidden grammar {in_rounds}for {time_per_item} seconds each.")
            else:
                self.duplicate_print(f"The training phase will now begin. You will have {self.settings.training_time} seconds to study a list of {self.settings.training_strings} exemplars of the hidden grammar.")
            self.duplicate_print('You can use Ctrl-Break on Windows or Ctrl-C on macOS/Unix to halt the experiment at any time.')
            self.duplicate_print('Please make sure your screen and terminal font are comfortable to read. Press return when you are ready.')
            input()
            if self.settings.training_one_at_a_time:
                for training_rep in range(1, self.settings.training_reps + 1):
                    for string in self.settings.experiment_state.training_set:
                        clear()
                        print()
                        self.duplicate_print(string)
                        time.sleep(float(self.settings.training_time) / self.settings.training_strings)
                    if training_rep < self.settings.training_reps:
                        clear()
                        self.duplicate_print(f"Round {training_rep} out of {self.settings.training_reps} done. Press return to start round {training_rep+1}.")
                        input()
            else:
                self.duplicate_print('Training phase started. Please study the following list of strings:')
                print()
                self.duplicate_print('\n'.join(self.settings.experiment_state.training_set))
                print()
                input_thread = threading.Thread(target=input, daemon=True)
                input_thread.start()
                remaining_time = self.settings.training_time
                while input_thread.is_alive() and 0 < remaining_time:
                    print(f"\r{remaining_time} seconds remaining (press return to finish early)...  ", end='')
                    time.sleep(1)
                    remaining_time -= 1
            print('\rTraining phase finished.' + ' ' * 30)
            self.duplicate_print('Training phase finished.', log_only=True)
            self.settings.experiment_state.training_finished = True
            clear()
        self.duplicate_print(f"The test phase will now begin. You will be shown {len(self.settings.experiment_state.test_set)} new strings one at a time and prompted to judge the grammaticality of each.")
        self.duplicate_print(f"You can use Ctrl-Break on Windows or Ctrl-C on macOS/Unix to halt the experiment at any time. Your progress will be saved to '{self.settings.filename}' and you will be able to finish the experiment later.")
        self.duplicate_print("You may type 'y' for yes (i.e. grammatical) and 'n' for no (ungrammatical). Press return when you are ready.")
        # recycle input_thread if it's still running...
        if input_thread and input_thread.is_alive():
            input_thread.join()
        else:
            input()
        # N.B. you can't do the following because you want to update the original test_set
        #for i, item in enumerate(self.settings.experiment_state.test_set):
        for i in range(len(self.settings.experiment_state.test_set)):
            if self.settings.experiment_state.test_set[i][2] is not None:
                # already answered in a previous session
                continue
            clear()
            self.duplicate_print(f"Test item #{i+1} out of {len(self.settings.experiment_state.test_set)}. Is the following string grammatical? (y/n)")
            self.duplicate_print(self.settings.experiment_state.test_set[i][0])
            answer = '_'
            while answer[0] not in ['y', 'n']:
                answer = None
                while not answer:
                    answer = input()
                answer = answer[0].lower()
                if answer == 'g':
                    answer = 'y'
                elif answer == 'u':
                    answer = 'n'
            self.duplicate_print(answer, log_only=True)
            self.settings.experiment_state.test_set[i] = (self.settings.experiment_state.test_set[i][0], self.settings.experiment_state.test_set[i][1], answer)
            # FIXME: need to call this manually because __setattr__ doesn't get called if you update a member variable in-place :(
            self.settings.save_all()
        clear()
        self.duplicate_print('Test phase finished. Hope you had fun!')

